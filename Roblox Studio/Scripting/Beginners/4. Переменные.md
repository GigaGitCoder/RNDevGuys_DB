<center> <iframe width="560" height="315" src="https://www.youtube.com/embed/Irtrmwc_L30?si=fpO-Hv0LJ4gmO0TC" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe> </center>

В видео рассказывается о переменных и кратко о принципе их работы. Для создания переменных пишется следующая структура:

```lua
local myVariable = 10
```

Переменные также можно спокойно выводить командой `print` и взаимодействовать с ней любым способом.

<div style="display: flex; align-items: center; text-align: center; margin: 20px 0;"> 
<hr style="flex-grow: 1; border: none; border-top: 1px solid #ccc; margin: 0 10px;"> <h1>Дополнительная информация</h1>
<hr style="flex-grow: 1; border: none; border-top: 1px solid #ccc; margin: 0 10px;"> </div>

Принцип переменных в **Lua** аналогичен тому, как это работает в **Python**.  
Переменные в Lua — это **ссылки на значения**, а не сами значения. Проще говоря, если мы пишем, что некая переменная равна, скажем, четырём, то мы **не "кладём" это значение внутрь переменной**, как это происходит в C++, а **присваиваем переменной ссылку на объект со значением `4`**.

Когда мы позже используем имя переменной, интерпретатор Lua просто **следует по этой ссылке** и получает доступ к значению. Это ключевой принцип, отличающий Lua от таких языков, как C или C++.

В **C++**, например, каждая переменная — это **ячейка памяти**, которая **физически содержит значение**. То есть присваивание копирует само значение, а не ссылку на него.

Рассмотрим это на понятных примерах:

```lua
-- Lua

a = 5
b = a
b = 10
print(a) -- 5
```

**Пояснение**:

- `a = 5`: переменная `a` ссылается на значение `5`.
    
- `b = a`: теперь `b` тоже ссылается на `5`.
    
- `b = 10`: `b` просто начинает ссылаться на **другое значение**, `10`.
    

```cpp
// C++

int a = 5;
int b = a;
b = 10;
std::cout << a;  // 5
```

**Пояснение**:

- `b = a` здесь означает, что **значение `a` копируется в `b`**.
    
- После этого `a` и `b` — это **две независимые ячейки памяти**.
    
- Изменение `b` не влияет на `a`.

На примерах с числами (и аналогично со строками) эта разница может показаться неочевидной, ведь иммутабельные значения просто заменяются при новом присваивании. Однако настоящая суть ссылочной природы переменных в Lua становится особенно заметной, когда мы начинаем работать с **изменяемыми объектами**, такими как **таблицы**. Именно в таких случаях мы можем наблюдать, как несколько переменных указывают на **один и тот же объект**, и изменение через одну переменную отражается на другой.

```lua
-- Lua

a = {x = 5}
b = a
b.x = 10
print(a.x)  -- 10
```

**Пояснение**:

- Здесь мы создаём **таблицу** `{x = 5}` и сохраняем на неё ссылку в переменной `a`.
    
- Затем `b = a` — это **копия ссылки**, теперь обе переменные `a` и `b` **указывают на одну и ту же таблицу**.
    
- Когда мы меняем `b.x = 10`, мы фактически **изменяем содержимое общего объекта**, на который ссылаются обе переменные.
    
- Поэтому `print(a.x)` выводит `10`, потому что это **одна и та же таблица**.

Если же мы присвоим `b` новую таблицу:

```lua
-- Lua

b = {x = 99}
```

То `b` начнёт ссылаться на **другую таблицу**, и `a` останется неизменной:

```lua
-- Lua

a = {x = 5}
b = a
b = {x = 99}
print(a.x)  -- 5
```

**Теперь возьмём такой же формат задачи только в C++:**

```cpp
// C++

#include <iostream>

struct Table {
    int x;
};

int main() {
    Table a = {5};
    Table b = a;  // Копирование содержимого, а не ссылки
    b.x = 10;
    std::cout << a.x << std::endl;  // 5 — a не изменился
}
```

**Пояснение**:

- `Table a = {5}` — создаём структуру с полем `x = 5`.
    
- `Table b = a` — **копируется весь объект**, `b` становится независимой копией.
    
- `b.x = 10` — изменение `b`, но `a` не затрагивается.
    
- Вывод: `5`, потому что `a` и `b` — **независимые объекты в памяти**.

<hr>

Эти знания не обязательны на начальном этапе изучения Lua, но со временем они помогут избежать непредсказуемого поведения в коде и значительно глубже понять, как устроен язык.